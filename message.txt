## **Game Design Document: ПРОЕКТ "ВЫЖИВАНИЕ" (Финальная Редакция)**

### **1. Ключевая Философия**

**"Выживание на последнем издыхании"**. Геймплей построен вокруг одной ключевой механики: постоянной потери HP. Игрок не может просто пассивно уворачиваться — он вынужден рисковать, собирая ресурсы, чтобы выжить и победить. Каждый ресурс — это одновременно и щит (восстановление HP), и меч (урон по боссу).

---

### **2. Базовые Механики Игры**

#### **Система Здоровья (HP)**
*   **Шкала:** от 100% до 0%.
*   **Пассивный расход:** **-2% HP в секунду.**
    *   **Важно:** Расход активен **только** во время основной фазы уровня (`level`). Во время фазы перехода (`transition`) расход HP **отключен**.
*   **Поражение:** HP достигает 0% — игра окончена (запускается анимация смерти).

#### **Система Взаимодействий**

*   **Красные Буквы/Картинки (Ресурс HP):**
    *   **Назначение:** Единственный способ выжить и победить.
    *   **При подборе:**
        1.  Игроку восстанавливается **+20% HP**.
        2.  Если на уровне есть активный босс, ему **мгновенно наносится 1 ед. урона**.
    *   Это ключевая двойная механика игры.

*   **Белые/Серые Буквы/Картинки (Угрозы):**
    *   **Назначение:** Препятствия, истощающие HP игрока.
    *   **При столкновении:**
        1.  Игроку наносится **-20% урона**.
        2.  Вражеский объект, с которым столкнулись, исчезает.
        3.  Проигрывается звук получения урона и срабатывает визуальный эффект (вспышка, тряска экрана).
    *   **Важно:** Столкновение **не убивает мгновенно**, а отнимает столько же HP, сколько дает один ресурс. Это создает интересный выбор: стоит ли рисковать и получать урон, чтобы добраться до спасительной красной буквы?

---

### **3. Структура Игры и Уровней**

Игра состоит из линейной последовательности уровней. Каждый уровень делится на две фазы:

#### **Фаза 1: Переход (`transition`)**
*   **Назначение:** Передышка, объявление нового этапа.
*   **HP Drain:** **Отключен.**
*   **События:** Отображение названия уровня. Враги и ресурсы отсутствуют.

#### **Фаза 2: Уровень (`level`)**
*   **Назначение:** Основной геймплей.
*   **HP Drain:** **Включен.**
*   **События:** Запускается сценарий уровня, управляющий появлением угроз и ресурсов.
*   **Условие завершения:**
    *   Для типа `survival`: Истекает таймер уровня.
    *   Для типа `boss`: HP босса достигает 0.

---

### **4. Бестиарий: Библиотека Чертежей**

#### **4.1. Ресурсы**

*   **`HP_RESOURCE` (Универсальный Ресурс)**
    *   **Тип:** `resource`
    *   **Визуал:** Любая **красная** буква или картинка. Символ может меняться для разнообразия, но цвет всегда красный.
    *   **Движение:** `flow` (прямолинейное). Направление (`up`, `down`, `left`, `right`) и скорость задаются в сценарии.
    *   **Эффект при подборе:** `+20% HP` игроку **И** `1` урон текущему боссу.

#### **4.2. Угрозы (Enemies)**

*   **`LETTER_THREAT` (Универсальная Угроза)**
    *   **Тип:** `threat` (враг)
    *   **Визуал:** Белая или серая буква/картинка. Конкретный символ и стиль задаются в сценарии.
    *   **Движение:** Может использовать любой паттерн:
        *   `flow`: Прямолинейное движение.
        *   `tracer`: Летит в последнюю известную позицию игрока.
        *   `oscillator`: Движется по синусоиде.
    *   **Эффект при столкновешении:** `-20% HP` игроку. Объект исчезает.

#### **4.3. Боссы (Bosses)**

Урон боссам наносится только при подборе `HP_RESOURCE`.

*   **`MINIBOSS_MAGIC_BAG`**
    *   **HP: 5**
    *   **Движение:** `patrol_top` (влево-вправо вверху экрана).
    *   **Атаки:** `ATTACK_GRAVITY_PULSE`.

*   **`MINIBOSS_CAPYBARA_BUNK`**
    *   **HP: 7**
    *   **Движение:** `static_top_center` (неподвижен).
    *   **Атаки:** `ATTACK_TRACER_LINE`.

*   **`MINIBOSS_GRIDSNAP_ADDON`**
    *   **HP: 3** (Сложность в выживании, а не в нанесении урона).
    *   **Движение:** `static_top_center`.
    *   **Атаки:** `ATTACK_WALL_SUMMON`.

*   **`FINAL_BOSS_ME`**
    *   **HP: 15**
    *   **Движение:** `chase_player_slowly` (медленно следует за игроком по горизонтали).
    *   **Фазы:**
        1.  **HP 15-8:** `ATTACK_GRAVITY_PULSE`, `ATTACK_TRACER_LINE`.
        2.  **HP 7-2:** Добавляется `ATTACK_WALL_SUMMON`, скорость атак растет.
        3.  **HP = 1 (Камбек):** Запускает `ATTACK_DESPERATION_STORM`.

#### **4.4. Атаки Боссов (Boss Attacks)**

*   **`ATTACK_GRAVITY_PULSE`**: Временно меняет траектории всех угроз на экране.
*   **`ATTACK_TRACER_LINE`**: Создает линию из 5 угроз-трассеров.
*   **`ATTACK_WALL_SUMMON`**: Создает движущиеся стены из угроз.
*   **`ATTACK_DESPERATION_STORM`**: Уникальная, срежиссированная атака финального босса. В конце этой атаки сценарий уровня создаст **один-единственный** `HP_RESOURCE`, давая игроку шанс нанести финальный удар и восстановить немного здоровья для последнего рывка.

---

### **5. Система Сценариев**

Игра управляется через детальные сценарии для каждого уровня. Сценарий — это массив событий, который точно определяет, когда и какие объекты появляются.

**Пример сценария для `LevelData[2]` (Босс Magic Bag):**

```javascript
[
    // Босс появляется сразу
    { time: 0, type: 'spawnBoss', config: { blueprint: 'MINIBOSS_MAGIC_BAG' } },

    // Первые ресурсы появляются через 3 секунды, давая шанс на атаку
    { time: 3, type: 'spawnResource', config: { blueprint: 'HP_RESOURCE', visual: { char: 'H' }, count: 1, position: 'random_top' } },
    { time: 5, type: 'spawnResource', config: { blueprint: 'HP_RESOURCE', visual: { char: 'P' }, count: 1, position: 'random_top' } },

    // Босс атакует, и сразу после этого появляется волна угроз, создавая сложную ситуацию
    { time: 7, type: 'bossAttack', config: { attack: 'ATTACK_GRAVITY_PULSE' } },
    { time: 7.5, type: 'spawnWave', config: { blueprint: 'LETTER_THREAT', char: 'M', count: 5, formation: 'v_shape' } },

    // После хаоса игроку дается шанс восстановиться
    { time: 10, type: 'spawnResource', config: { blueprint: 'HP_RESOURCE', visual: { char: 'H' }, count: 2, position: 'random_middle' } }
]
```

Отлично, давайте проанализируем ваш текущий код и посмотрим, какие части предложенной архитектуры у вас уже есть, а что предстоит создать.

### **Что у вас уже есть (Сильные стороны и фундамент)**

Вы уже создали очень солидную базу, которая идеально подходит для дальнейшего расширения.

#### **1. Карта Игры (Файл `levels.js`)**

*   ✅ **У вас есть:** `LevelData` — это и есть ваша **"Карта Игры"**.
*   ✅ **Вы уже реализовали:**
    *   **Порядок уровней:** Определяется ключами (1, 2, 3...).
    *   **Типы уровней:** `type: 'survival'` и `type: 'boss'`.
    *   **Настройку длительности:** `transitionDuration` и `levelDuration` уже существуют и используются.

**Оценка:** Эта часть готова на 90%. Нам нужно будет только добавить в нее поле `scenario` для каждого уровня, чтобы связать его с "покадровым планом".

#### **2. Базовая структура сценария (Файл `scenario.js`)**

*   ✅ **У вас есть:** Отличная система смены уровней и фаз (`transition` -> `level`).
*   ✅ **Вы уже реализовали:**
    *   **Диспетчер уровней:** `startScenario()` и `endCurrentLevel()` прекрасно управляют переходом между уровнями.
    *   **Диспетчер фаз:** `startTransitionPhase()` и `startLevelPhase()` четко переключают состояния внутри уровня.
    *   **Таймер фазы:** `Game.phaseTimer` уже отсчитывает время внутри каждой фазы.
    *   **Логика завершения уровней:** `updateScenario` корректно проверяет `levelDuration` для уровней на выживание.

**Оценка:** Это идеальный "скелет" для нашего **"Движка Сценария"**. Он уже умеет переключать уровни и отсчитывать время. Нам нужно будет "нарастить на него мясо" — научить его читать массив событий из `LevelData.scenario` внутри фазы `level`.

#### **3. Базовая система противников (Файл `enemies.js`)**

*   ✅ **У вас есть:** Начальная система для управления массивом врагов `Game.enemies`.
*   ✅ **Вы уже реализовали:**
    *   **Жизненный цикл врага:** Функции `updateEnemies` и `renderEnemies` уже существуют.
    *   **Обнаружение столкновений:** `checkCollisions` корректно обрабатывает столкновения игрока с врагами.
    *   **Систему удаления (деспаун):** Логика с `isFadingOut` и `toRemove` уже работает.

**Оценка:** Это хорошая основа для **"Фабрики Врагов"**. Сейчас она "захардкожена" (жестко прописана) на один тип поведения (движение вниз), но все базовые функции (создание, обновление, удаление) уже на месте.

---

### **Чего у вас пока нет (Что предстоит создать)**

#### **1. Каталог Актеров и Реквизита (Файл `blueprints.js`)**

*   ❌ **Отсутствует:** Сейчас у вас нет централизованного места, где описаны все типы врагов, ресурсов и боссов. Логика врага размазана по `convertPromptToEnemies` (начальное состояние) и `updateEnemies` (поведение).
*   **Задача:** Создать новый файл `blueprints.js`, который будет содержать тот самый "Бестиарий" — объект с чертежами всех игровых сущностей.

#### **2. Детальные Сценарии по Сценам (Папка `scenarios/` или просто расширение `levels.js`)**

*   ❌ **Отсутствует:** Ваш `LevelData` пока описывает только общую структуру уровня, но не то, **что** в нем происходит.
*   **Задача:** Расширить каждый объект в `LevelData`, добавив в него массив `scenario`, который будет содержать покадровый план событий (`{ time: X, type: Y, ... }`).

#### **3. Исполнитель Событий (Новые функции в `scenario.js`)**

*   ❌ **Отсутствует:** У вас нет механизма, который бы читал события из сценария и превращал их в действия.
*   **Задача:**
    1.  **Модифицировать `updateScenario`:** Добавить в `case 'level':` логику, которая будет проверять `Game.phaseTimer` и сравнивать его со временем следующего события в `LevelData[Game.currentLevel].scenario`.
    2.  **Создать `executeScenarioEvent(event)`:** Новая функция, которая будет принимать объект события и вызывать соответствующие функции-исполнители (например, `spawnWave`, `spawnBoss`).

#### **4. Фабрика Врагов и Модули Поведения**

*   ❌ **Отсутствует:** Ваша текущая система врагов умеет только одно — двигаться вниз. Нет поддержки разных паттернов движения, атак и т.д.
*   **Задача:**
    1.  **Создать `spawnWave(config)` и `spawnResource(config)`:** Эти функции заменят `convertPromptToEnemies`. Они будут читать `blueprint` из конфига, создавать DOM-элемент, добавлять его в массив `Game.enemies` (или `Game.resources`) и задавать ему начальные свойства (скорость, направление) согласно чертежу и конфигу.
    2.  **Создать `movementPatterns.js`:** Файл с функциями `flow()`, `tracer()`, `oscillator()`.
    3.  **Модифицировать `updateEnemies`:** Вместо `enemy.y += ...` она будет вызывать нужную функцию из `movementPatterns` для каждого врага в зависимости от его `enemy.movement.pattern`.

#### **5. Инструменты Режиссера (Дебаг-функции)**

*   ❌ **Отсутствует:** У вас пока нет удобных инструментов для быстрой итерации и тестирования.
*   **Задача:** Добавить в `handleGameInput` обработку клавиш `L` (загрузить уровень) и `R` (перезапустить текущий уровень), которые будут вызывать соответствующие функции для быстрой навигации по игре во время разработки.

---

### **Вывод**

Вы на очень правильном пути! У вас есть прочный "скелет" игры. Следующий шаг — нарастить на него "мышцы": создать **библиотеку чертежей (`blueprints.js`)** и научить ваш **движок сценариев (`scenario.js`)** читать эти чертежи и детальные планы уровней, чтобы оживить ваш мир.